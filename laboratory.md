

# Relevant PINS and connections
PINS list and peripherals:
- green led: PA5
- push button (blue): PC13
- microphone: PA8
- speaker: PA9 -> TIM1_CH2
- potentiometer: PA1
- encoder: PC7 (TIM3_CH2), PC6 (TIM3_CH1)
- keyboard: PC8,9,10,11 OUTPUT (column driver), PC12,13,2,3 INPUT (row readout)
- LCD: PB12,13,14,15 as GPIO_Output, PB1,2 as GPIO_Output, PA4 as GPIO_Output
- USART2:
    - Rx: PA3
    - Tx: PA2
- I2C: PB9->SDA, PB8->SCL
	- temperature address LM75: 0b10010000
	- accelerator address: LIS2DE: 0b01010000
- SPI: (1,4 up to 42Mbps; 2,3 up to 21Mbps)
	- PA5 (SCK), PA6(MISO), PA7(MOSI), PB6 (FOR LEDMATRIX: after transfer complete, SET and then RESET)
- IR: PB10 (Led attached to TIM2_CH3) and PA10 (receiver USART1RX)


# CHEATSHEET LABORATORIES

## GPIO:

Code:
- `HAL_GPIO_ReadPin(GPIOC_BASE, GPIO_PIN_13)` // pin PC13
- `HAL_GPIO_WritePin(GPIOA_BASE, GPIO_PIN_5, GPIO_PIN_RESET | GPIO_PIN_SET)` // pin PA5 set or reset
- `HAL_GPIO_TogglePin(GPIOA_BASE, GPIO_PIN_5)` // pin PA5

INTERRUPT MODE:
- set the pin to be in GPIO_EXTIx 
- enable in NVIC the EXTI interrupts that include x
- check whether the interrupt routine is called on the rising or falling edge of the external event
- write function `void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)`
- inside the callback, check the origin of the GPIO interrupt with `switch (GPIO_Pin) {case GPIO_PIN_13:}`

Disabling interrupts with `HAL_NVIC_DisableIRQ(EXTI9_5_IRQn)` 

---

## Delay function

`HAL_Delay(milliseconds)` generates a blocking interrupt when called. It blocks completely the microcontroller thatâ€™s why we want to avoid using it, we can use otherwise a timer.

`__HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin)` can be used to clear the interrupt flag in the NVIC, however calling this function is bad practice.

Concurrent interrupt execution problem when they are triggered at the same time:

> The `HAL_Delay(milliseconds)` generates itself an interrupt so what happens is that this interrupt and the one generated by the microphone happen at the same time.
> So we must clarify which one has the higher priority, otherwise if the speaker is playing, at the same time the microphone detects a loud sound and its event gets triggered again.
> There are different ways of handling this problem:
> - In the NVIC configuration there in the upper part there is a menu called priority group that must be set to 1 bit (otherwise we cannot enable different priorities) then there is a column called pre-emption priority and we can set to 1 the interrupt that has less priority, which in this case is EXTI line [9:5] interrupts (the microphone).
> - This is not enough because even if now the microphone has less priority, at the end of the entire song the pin is always checked, and since it is high it means that it has to be considered. So what we have to do in the code is at the and of the song to set the pin to 0, in order to not let the song restart again.
> - Another way to do the project without using the priorities is to use a flag variable inside the code which enables the loop of playing a song changing it whenever is detected a sound by the microphone and set it at the original variable whenever the song is finished.


---

## Timer:

base timer setup: clock source = internal clock

change ARR and PSC values (by fixing one value and varying the other), to obtain the desired PWM frequency, with the formula:
$f_{PWM} = \frac{f_{tim}}{(ARR+1) (PSC+1)}$

using interrupt: NVIC settings -> enable global interrupt

- `void HAL_TIM_Base_Start_IT(&htimx);` // starts timer x with interrupt routine callback
- `void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)` // callback for timer expiring

+ `__HAL_TIM_SET_AUTORELOAD(&htim1, arr)` //Change dynamically the content of the autoreload register
+ `__HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_2, pulse)` // capture and compare register, associated to the pulse
+ `__HAL_TIM_SET_COUNTER(&htim1, 0)` // resets timer counter variable


---

## PWM:

PWM (pulse width modulator) generation: the counter grows since it overflows at a certain time and it gets reset. It counts until it reaches the autoreload register (full scale range). The frequency of the PWM fpwm is defined by the ARR and the PSC because the ftim is fixed at 84 MHz.

formula: $f_{PWM} = \frac{f_{tim}}{(ARR+1) (PSC+1)}$

Parameter settings:
- set pin to be active in mode TIMx_CHy (where x = timer number and y = channel of peripheral)
- set TIMx clock source as internal clock
- set TIMx channel y to be in mode "PWM Generation CHy"
- set prescaler (PSC) and counterperiod (ARR)
- set pulse of the PWM (capture and compare register) as ARR *  duty cycle
- `HAL_TIM_PWM_Start(&htimx, TIM_CHANNEL_y)`
- `HAL_TIM_PWM_Stop(&htimx, TIM_CHANNEL_y);`

---

## UART:

set pins for Tx and Rx (already set by default)

- `HAL_UART_Receive(UART_HandleTypeDef*huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)` 
- `HAL_UART_Transmit(UART_HandleTypeDef*huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)`
  
Note: data is a string pointer, size the length of the string

__DMA__: 
- add Tx DMA entry on DMA settings
- enable global interrupt in NVIC settings
- enable normal mode and check the memory flag. as default data width is set to bytes 
- `void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)`

---

## ADC:
There are three main modes of operation (__end of conversion__):
- Polling mode: checks at every loop iteration whether the conversion finished. 
> `while(HAL_ADC_PollForConversion(&hadc1, 1000) != HAL_OK)`

- Simple interrupt mode: the ADC provides an interrupt at the end of the conversion and reads directly the value from the peripheral
> `HAL_ADC_Start_IT(&hadc1)`

- DMA mode with interrupt: the ADC provides an interrupt when the value read from the peripheral is written on memory and ready to be accessed. DMA settings > add > Mode: Circular. DMA continuous requests: enabled
> `HAL_ADC_Start_DMA(&hadc1, (uint16_t*) data, bufflen)`

There are three modes of __starting the conversion__:
- software-based: external trigger conversion = regular conversion started by software + delay to pause the conversions + ADC start in the while loop
- timer-based: external trigger conversion = timer 2 trigger out event + timer base start (configure timer 2 for the frequency of acquisition and set internal clock source & Trigger Event Selection = Update Event) + ADC start (outside while loop)
- external trigger source (EXTI_11 or EXTI_15)


In the example the sampling time is set to 480 cycles.

In order to read the value of the ADC, with values from 0 to 4096 (2^12):
> `HAL_ADC_GetValue(&hadc1)`

Interrupt callbacks for reading the converted value
- Interrupt callback at half word: `void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef *hadc)`
- Interrupt callback at full word: `void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)`

Pin connections and ADC channel:
- PA0: ADC1_IN0 for the light LDR sensor
- PA1: ADC1_IN1 for the potentiometer

Configuration of the ADC parameters:
- set the pin PA1 as ADC_IN1
- check that IN1 is flagged in the ADC settings
- conversion mode: can be set to *regular* or *circular* depending on how to read the values and how many channels to read from
- external trigger conversion: [software OR Timer 2 Trigger Out event] for selection of the start of conversion

If many values are read, then different channels need to be sampled (IN1, temperature sensor channel and Vref):
- ADC_Regular_ConversionMode > NumberOfConversions = #values (or of different sensors to be sampled)
- set the correct Channels in every "Rank" label (and 480 cycles)

---

## I2C: 
half-duplex, only 2 wires for all the connected devices (SCL clock and SDA data) but it's slow (max 400kbps in fast mode). wires are open drain, so we have a pull up that brings them at Vdd if nobody sets nothing

Used for interfacing with the LDR temperature sensor and the accelerometer LIS2DE

Parameters settings:
- I2C pins: PB9->SDA, PB8->SCL
- enable I2C1 communication
- receive callback function: enable NVIC settings -> event interrupt flag
- DMA: enable RX DMA channel with default settings and normal mode

functions:
- `HAL_I2C_Master_Transmit(&hi2c1, accAddress, dataBuf, 1, 10);` // dataBuf = uint8 register where data is stored by the peripheral
- `HAL_I2C_Master_Receive(&hi2c1, accAddress, accBuf, 2, 10);` // accBuf = buffer of uint8_t data received
- `HAL_I2C_Master_Receive_DMA(&hi2c1, accAddress, accBuf, 2);` // accBuf = buffer of uint8_t data received
- `void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)`	// callback called when data reception is completed
- // accAddress = address of peripheral to access


---

## SPI: 
(only led matrix) full-duplex, short distance communication, higher speed (42 Mbps SPI1,SPI4, 21 Mbps SPI2,SPI3)

LEDMATRIX code: SET gpio pb6, then transmit single column complete, then RESET gpio pb6

Parameter settings: 
- use prescaler = 4, CPOL = low, CPHA = 1Edge
- {dataValue, colValue} MSB top-left
- Pin PA5 = SPI1_SCK; Pin PA7 = SPI_MOSI; Pin PB6 = GPIO_Output.
- SPI Mode: Transmit only master
- timer: quick enough to see continuous light (update all the led matrix in less than 4ms -> frequency > 1250Hz)
- DMA: add DMA with TX mode and default settings

Code:
- `HAL_SPI_Transmit(SPI_HandleTypeDef*hspi, uint8_t * pData, uint16_t Size, uint32_t Timeout)` // transmission of string pData
- `HAL_SPI_Transmit_DMA(SPI_HandleTypeDef*hspi, uint8_t * pData, uint16_t Size)` // no timeout required

---

## ENCODER: 
enable PC6 = TIM3_CH1, PC7 = TIM3_CH2

Parameter settings:
- TIM3 combined channels = Encoder Mode
- first channel 1 -> polarity = falling edge, input filter = 15
- second channel 2 -> polarity = rising edge, input filter = 15
- `__HAL_TIM_GET_COUNTER(&htim3)` // to get the absolute value of the encoder rotation
- `HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_ALL);` // start encoder timers

---

## Keyboard: 
Pins: PC8,9,10,11 GPIO OUTPUT (column driver), PC12,13,2,3 GPIO INPUT (row readout)

Row is set to ground (0 value) if a button in the row is pressed, otherwise, if no buttons are pressed, the row is set to 1
debounce: register more presses of the button to validate it
- columns in order = 8 - 9 - 10 - 11
- rows in order = 12 - 13 - 2 - 3

Keyboard mapping buttons to a character:

`char map [16] = "FB73EA62D951C840";` // columns in the map: 10 9 8 11 //rows in the map: 3 2 13 12

---

#### ENABLE FLOATING POINT PRINTFS
Project -> properties -> C/C++ build -> Settings -> MCU settings -> check printf_float

---

# PROJECTS

### **ADC**

- **TODO**: Lab 04 (proj1 modified): ADC-polling: ADC start + poll for conversion + software start in while loop
	
- HW04: ADC interrupt UART: ADC interrupt + Tim2 trigger out event (in TIM2: Trigger output=Update Event) when conversion ends callback called + output via UART interface
- HW04. ADC interrupt LCD: ADC interrupt + Tim2 trigger out event callback + writing on LCD with drawbar

- **TODO**: Lab 05 (proj3a): ADC DMA read 3 values: in while(1) HAL_ADC_Start_DMA with buffer of uint16_t. reads potentiometer, temperature of MCU, Vref, output via UART interface

- HW05: ADC read LDR with DMA and timer interrupt: reading LDR 1000 a second and sending average every second. Using DMA with length 2000 and reading both in half and full complete

### **I2C**

Lab06. I2C-TemperatureSensor: (temperature addr = 0b10010000), reading only the MSB

HW06:  I2C-TemperatureSensorFull: read MSB and LSB (2 bytes)

LAb07 I2C-Accelerometer: reading 3 registers with I2C

HW07: I2C-Accelerometer-Interrupts-UART_DMA: using also UART DMA and a timer interrupt to trigger the sampling

HW07: I2C-Accelerometer-I2C_DMA-Interrupts-UART_DMA: using also I2C DMA (only in reception)
	

### **SPI**
HW08 : SPI-DMA-LedMatrix: two or more letters changing
	
### **Encoder**
HW09 : encoder readout with velocity, considering overflow and underflow

### **Keyboard**
HW10 : keyboard-DMA: polling read of keyboard, usage of timer interrupt for selection
	
### **IR**
- IR-Receiver: infrared communication receiver. receives data in UART protocol (from UART1) modulated at 38kHz and sends every byte received to the default serial port (UART2).
- IR-Transceiver: both ends of the infrared communication, the transmitting part (that implements literally the uart protocol with the modulation of 38kHz) and the receiving part (that implements the already present receiving part)
- IR-Transceiver-Accelerometer: both ends of the infrared communication, transmitting the three accelerations on the three axis as values (not as formatted strings) and printing them on the LCD. usage of libraries

### Exams question samples
1. Exam22-12: scanning the LDR 1000 times and return the average. Stopping the conversion when pressed a corner keybutton of the keyboard
2. exam-24-02: both ends of the infrared communication, transmitting the temperature of the I2C sensor (not as formatted strings) and printing it on the LCD